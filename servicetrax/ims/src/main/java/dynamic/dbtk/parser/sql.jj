/*
 * Highly modified for SQL queries by bvonhaden from the following source:
 */

/* ................................................................... *
 * FILE: FormsPlSql.jj                                                 *
 *                                                                     *
 * DESCRIPTION: This file contains the entire grammar for PLSQL inside *
 * Oracle*Forms 4.5(i.e. PlSql 1.x)                                    *
 *                                                                     *
 * HISTORY: 07-APR-1997 Created  Ramanathan .S (sramji@rocketmail.com) *
 * HISTORY: 13-OCT-2000 Modified R. Blake Von Haden                    *
 *                                                                     *
 * NOTE: Read the file FormsPlSql.readme for more info                 *
 * ................................................................... */


options{
    IGNORE_CASE=true ;
    STATIC = false;
    //BUILD_PARSER = false;
//  DEBUG_LOOKAHEAD= true ;
}

PARSER_BEGIN(Sql)

package dynamic.dbtk.parser;

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.StringReader;
import java.util.Enumeration;
import java.util.Vector;

import dynamic.util.diagnostics.Diagnostics;
import dynamic.util.string.StringUtil;


/**
 * A parser for SQL Statements generated by JavaCC.
 * Use getQuery to get the fully constructed query.
 * The get*** clauses are only useful for breaking up the first top level query.
 *
 * <P>NOTE: Only edit the sql.jj file, not the Sql.java file.
 *
 * <pre>
 *  SQL jp;
 *	jp = Sql.fetchSql("SELECT * FROM cat c");
 *  jp.addWhereAndClause("c.color = 'white'");
 *  String query = jp.getQuery();
 * </pre>
 *
 * To compile this, use something like the following command:
 * <pre>
 * d:\dev\javacc2.0\bin\javacc.bat -OUTPUT_DIRECTORY:"d:\work\iframe2\src\dynamic\dbtk\parser" d:\work\iframe2\src\dynamic\dbtk\parser\sql.jj
 * </pre>
 *
 * @version $ID$
 */
public class Sql
{
	private String[] query = new String[1];	// internal query storage
	private int level = 0;	// Parenthesis matching
	private boolean firstQuery = true;

	// Store the tables in the FROM clause.
	private Vector tables = new Vector();
	// Store WHERE clause fragments.
	private Vector whereFrags = new Vector();

	/**
	 * This constructor is not very useful.
	 */
	public Sql()
	{
	}


	/**
	 * Take a query and return it in a parsed object.
	 */
	public static Sql fetchSql(StringBuffer query) throws ParseException
	{
		return fetchSql(query.toString());
	}

	/**
	 * Take a query and return it in a parsed object.
	 */
	public static Sql fetchSql(String query) throws ParseException
	{
		StringReader reader = new StringReader(query);
		Sql temp = new Sql(reader);
		temp.setQuery(query);
		// Run the parse.
		temp.SelectStatement();
		return temp;
	}

	/**
	 * @return the constructed query
	 */
	public String getQuery()
	{
		StringBuffer tempQuery = new StringBuffer(getSelect());

		String s = getFrom();
		tempQuery.append(getWhiteSpace(s, tempQuery));
		tempQuery.append(s);
		s = getWhere();
		tempQuery.append(getWhiteSpace(s, tempQuery));
		tempQuery.append(s);
		s = getConnect();
		tempQuery.append(getWhiteSpace(s, tempQuery));
		tempQuery.append(s);
		s = getGroupBy();
		tempQuery.append(getWhiteSpace(s, tempQuery));
		tempQuery.append(s);
		s = getSet();
		tempQuery.append(getWhiteSpace(s, tempQuery));
		tempQuery.append(s);

		if (includeOrderBy == true)
		{
			s = getOrderBy();
			tempQuery.append(getWhiteSpace(s, tempQuery));
			tempQuery.append(s);
		}

		s = getForUpdate();
		tempQuery.append(getWhiteSpace(s, tempQuery));
		tempQuery.append(s);

		return tempQuery.toString();
	}

	String getWhiteSpace(String aClause, StringBuffer tempQuery)
	{
		if (aClause.length() > 0 && !StringUtil.isWhitespace(aClause.charAt(0))
		 && tempQuery.length() > 0 && !StringUtil.isWhitespace(tempQuery.charAt(tempQuery.length()-1)))
		{
			return " ";
		}
		else
			return "";
	}

	private boolean distinct = false;

	/**
	 * If an n-way join is added, a DISTINCT clause is necessary
	 */
	public void setDistinct()
	{
		distinct = true;
	}

	/**
	 * The list of tables used in the primary query FROM clause stored in QueryTable objects.
	 *
	 * @return a vector of the tables in the FROM clause.
	 */
	public Vector getTables()
	{
		return tables;
	}

	/**
	 * @return the alias for the given table, null if no alias found.
	 */
	public String getTableAlias(String name)
	{
		String alias = null;
		Enumeration tableList = tables.elements();
		while (tableList.hasMoreElements())
		{
			QueryTable qt = (QueryTable)tableList.nextElement();
			if (qt.getName().equalsIgnoreCase(name))
			{
				alias = qt.getAlias();
				break;
			}
		}
		return alias;
	}

	/**
	 * @return the table name for the given alias, null if no alias found.
	 */
	public String getTableForAlias(String alias)
	{
		String tableName = null;
		Enumeration tableList = tables.elements();
		while (tableList.hasMoreElements())
		{
			QueryTable qt = (QueryTable)tableList.nextElement();
			if (qt.getAlias().equalsIgnoreCase(alias))
			{
				tableName = qt.getName();
				break;
			}
		}
		return tableName;
	}

	/**
	 * Create a new table alias that is not already
	 * being used in this query.
	 *
	 * @return the new alias for the given table
	 */
	public String createTableAlias(String name)
	{
		String aliasRoot = name.substring(0,1);
		String alias = null;

		// Even if all the tables have aliases that match the
		// generated alias naming pattern, once more through
		// the loop guarantees a unique alias.
		for (int i = 0; i <= tables.size()+1; i++)
		{
			alias = aliasRoot + i;
			boolean found = false;
			Enumeration tableList = tables.elements();
			while (tableList.hasMoreElements())
			{
				QueryTable qt = (QueryTable)tableList.nextElement();
				if (qt.getAlias().equalsIgnoreCase(alias))
				{
					found = true;;
				}
			}
			if (found != true)
			{
				break;
			}
		}
		return alias;
	}

	/**
	 * @return true if the table is in the FROM clause
	 */
	public boolean foundTable(String name)
	{
		boolean found = false;
		Enumeration tableList = tables.elements();
		while (tableList.hasMoreElements())
		{
			if (((QueryTable)tableList.nextElement()).getName().equalsIgnoreCase(name))
			{
				found = true;
				break;
			}
		}
		return found;
	}

	/**
	 * @return true if the table alias is in the FROM clause
	 */
	public boolean foundTableAlias(String alias)
	{
		boolean found = false;
		Enumeration tableList = tables.elements();
		while (tableList.hasMoreElements())
		{
			if (((QueryTable)tableList.nextElement()).getAlias().equalsIgnoreCase(alias))
			{
				found = true;
				break;
			}
		}
		return found;
	}


	private ParserClause selectClause = new ParserClause();
	private ParserClause distinctClause = new ParserClause();

	/**
	 * @return the SELECT portion of the statement.
	 */
	public String getSelect()
	{
		String selectFrag = null;
		if (distinct)
		{
			String checkDistinct = distinctClause.getClause();
			if (checkDistinct.trim().equalsIgnoreCase("DISTINCT"))
			{
				selectFrag = selectClause.getClause();
			}
			else
			{
				// Force the distinct clause
				ParserClause part = new ParserClause();
				part.setBegin(selectClause.begin.column, selectClause.begin.line);
				part.setEnd(distinctClause.begin.column, distinctClause.begin.line);
				selectFrag = part.getClause() + " DISTINCT";
				part.setBegin(distinctClause.begin.column, distinctClause.begin.line);
				part.setEnd(selectClause.end.column, selectClause.end.line);
				selectFrag += part.getClause();
			}
		}
		else
		{
			selectFrag = selectClause.getClause();
		}

		return selectFrag;
	}


	private ParserClause fromClause = new ParserClause();

	/**
	 * @return the FROM portion of the statement.
	 */
	public String getFrom()
	{
		StringBuffer tempFrom = new StringBuffer(getOriginalFrom());

		if (tables.size() > 0)
		{
			Enumeration tableList = tables.elements();
			while (tableList.hasMoreElements())
			{
				QueryTable curTab = (QueryTable)tableList.nextElement();
				if (!curTab.isOriginal())
				{
					tempFrom.append(", ");
					tempFrom.append(curTab.toString());
				}
			}
		}
		return tempFrom.toString();
	}

	/**
	 * @return the original FROM portion of the statement.
	 */
	public String getOriginalFrom()
	{
		return fromClause.getClause();
	}


	private ParserClause whereClause = new ParserClause();

	/**
	 * @return the original WHERE portion of the statement.
	 */
	public String getOriginalWhere()
	{
		return whereClause.getClause();
	}

	/**
	 * @return the WHERE portion of the statement.
	 */
	public String getWhere()
	{
		StringBuffer tempWhere = new StringBuffer(getOriginalWhere());

		Enumeration whereClauseList = whereFrags.elements();
		while (whereClauseList.hasMoreElements())
		{
			WhereClause whereFrag = (WhereClause)whereClauseList.nextElement();

			if (tempWhere.length() > 0)
			{
				tempWhere.append(" ");
				if (whereFrag instanceof AndClause )
					tempWhere.append("AND ");
				else
					tempWhere.append("OR ");
			}
			else tempWhere.append("WHERE ");

			tempWhere.append(whereFrag.toString());
		}
		return tempWhere.toString();
	}


	private ParserClause connectClause = new ParserClause();

	/**
	 * @return the CONNECT portion of the statement.
	 */
	public String getConnect()
	{
		return connectClause.getClause();
	}


	private ParserClause groupByClause = new ParserClause();

	/**
	 * @return the GROUP BY portion of the statement.
	 */
	public String getGroupBy()
	{
		return groupByClause.getClause();
	}


	private ParserClause orderByClause = new ParserClause();
	private String overrideOrderByClause;
	private boolean includeOrderBy=true;

	/**
	 * @return the ORDER BY portion of the statement.
	 */
	public String getOrderBy()
	{
		if (overrideOrderByClause == null)
			return orderByClause.getClause();
		else
			return overrideOrderByClause;
	}

	/**
	 * Replace the existing order by statement.
	 * Must start with "ORDER BY"
	 *
	 * @param replace the existing order by clause.
	 */
	public void setOrderBy(String overrideOrderByClause)
	{
		this.overrideOrderByClause = overrideOrderByClause == null ? "" : overrideOrderByClause;
	}

	/**
	 * Call this with false if no order by is wanted.
	 * The default is that the order by clause will be included.
	 */
	public void includeOrderBy(boolean includeOrderBy)
	{
		this.includeOrderBy=includeOrderBy;
	}


	private ParserClause forUpdateClause = new ParserClause();

	/**
	 * @return the FOR UPDATE portion of the statement.
	 */
	public String getForUpdate()
	{
		return forUpdateClause.getClause();
	}


	private ParserClause setClause = new ParserClause();

	/**
	 * This may contain all the statements following the primary statement
	 * connected by a UNION, MINUS or INTERSECT
	 *
	 * @return the set portion of the statement.
	 */
	public String getSet()
	{
		return setClause.getClause();
	}



	/**
	 * Add a table to the FROM clause.
	 *
	 * @param name the name of the table
	 * @param alias the alias for the table
	 */
	public void addFromTable(String name, String alias)
	{
		tables.addElement(new QueryTable(name, alias));
	}


	/**
	 * Add a WHERE clause fragment to the query.
	 */
	public void addWhereAndClause(String clause)
	{
		whereFrags.addElement(new AndClause(clause));
	}

	/**
	 * Add a WHERE clause fragment to the query.
	 */
	public void addWhereOrClause(String clause)
	{
		whereFrags.addElement(new OrClause(clause));
	}


	/**
	 * Test harness.
	 * If a file name is given, the statement from the file will be read and parsed.
	 * Otherwise, the hard coded statement will be used.
	 */
	public static void main( String args[] )
	throws ParseException
	{

		Sql jp = null;

		if ( args.length < 1  )
		{
			String query = null;
			System.out.println("Using fixed SQL");

			if (true)
			{
			query = "SELECT wo.work_order_id id, wo.work_order_number, wo.name work_order_name, wot.name order_type,"
			+" stata.status_label(wo.work_order_id, wos.code, wo.due_date, wo.site_id) order_status,"
			+" stata.status_color(wo.work_order_id, wos.code, wo.due_date, wo.site_id) order_status_color,"
			+"  atype.name asset_type, o.name site,"
			+"  nvl(rtrim(c.call_number), ' ') call_number, c.call_id, to_char(wo.date_reported,'MM/DD/YYYY hh:mm') date_reported,"
			+"  wo.date_reported sort_date_reported, a.serial_number"
			+" FROM work_orders wo, work_order_types wot,"
			+" status wos, asset_types atype, organizations o,"
			+" calls c, assets a"
			+" WHERE (1 is NULL OR o.affiliation_type_id = 1)"
			+" AND (NULL is NULL OR o.organization_id = 1)"
			+" AND o.organization_id IN (SELECT organization_id FROM organizations"
			+"  START WITH organization_id = 2"
			+"  CONNECT BY PRIOR organization_id = parent_organization_id)"
			+" AND (1 is NULL OR wos.code IN(1,2))"
			+" AND 1 is NULL OR a.asset_id = 1"
			+" AND wo.work_order_type_id = wot.work_order_type_id (+)"
			+"  AND wo.asset_type_id = atype.asset_type_id (+)"
			+" AND wo.site_id = o.organization_id (+)"
			+" AND wo.call_id = c.call_id (+)"
			+" AND wo.status_id = wos.status_id(+)"
			+" AND wo.asset_id = a.asset_id (+)"
//			+" ORDER BY o.name, wo.work_order_number";
//			}
//
//			if (true)
//			{
//			query = "SELECT w.work_order_id work_order_id, w.work_order_number,w.name name,"
			+ " UNION SELECT w.work_order_id work_order_id, w.work_order_number,w.name name,"
			+" w.approval_comment approval_comment, wot.name work_order_type,"
			+" to_char(w.date_completed,'MM/DD/YYYY hh:mm') date_completed, w.date_completed sort_date_completed,ast.name asset_type,"
			+" decode( (w.billable_time*organization_provider.hourly_rate), NULL, 'Hourly rate or billable time not set.', (w.billable_time * organization_provider.hourly_rate) ) billable_labor,"
			+" SUM(NVL(pu.actual_price*pu.quantity, 0)) parts_total_cost, act.activity_id activity_id, wc.name work_center, wos.name status, "
			+" DECODE(wos.code, 'REJECTED', 'checked', '') reject_status"
			+" FROM work_orders w, parts_used pu, asset_types ast, work_order_types wot, status wos, activities act, assets a, work_centers wc, organizations organization_site, organizations organization_provider"
			+" WHERE "
			+" (wos.code = 'COMPLETED' OR wos.code = 'REJECTED' OR wos.code = 'LIMITEXCEEDED')"
			+" AND wos.status_id = w.status_id"
			+" AND w.asset_type_id = ast.asset_type_id"
			+" AND wot.work_order_type_id = w.work_order_type_id"
			+" AND w.site_id =  1"
			+" AND w.work_order_id = act.work_order_id(+)"
			+" AND w.asset_id = a.asset_id (+)"
			+" AND a.work_center_id = wc.work_center_id(+)"
			+" 	AND a.organization_id = organization_site.organization_id"
			+" AND w.work_order_id = pu.work_order_id(+)"
			+" AND w.provider_id = organization_provider.organization_id"
			+" GROUP BY w.work_order_id, date_completed, w.work_order_number,w.name, w.approval_comment, wot.name, ast.name, w.billable_time  , act.activity_id, wc.name, wos.name, wos.code, date_completed, wos.code, organization_site.hourly_rate, organization_provider.hourly_rate"
			+" ORDER BY date_completed, wos.code";
			}


			jp = Sql.fetchSql(query);

			if (true)
			{
	 			System.out.println("query = " + query);
	 			System.out.println("select = " + jp.getSelect());
	 			System.out.println("from = " + jp.getFrom());
	 			System.out.println("where = " + jp.getWhere());
	 			System.out.println("connect = " + jp.getConnect());
	 			System.out.println("groupBy = " + jp.getGroupBy());
	 			System.out.println("orderBy = " + jp.getOrderBy());
	 			System.out.println("set = " + jp.getSet());
	 			Vector tables = jp.getTables();
	 			for (int i = 0; i < tables.size(); i++)
	 			{
	 				QueryTable qt = (QueryTable)tables.elementAt(i);
	 				System.out.println("table " + (i+1) + ", name = " + qt.getName() + ",alias = " + qt.getAlias());
	 			}
	 			jp.addWhereAndClause("w.name = 'Fred'");
	 			jp.addFromTable("table_name1", "alias1");

				System.out.println("CONSTRUCTED="+jp.getQuery());

			}

			System.out.println("Parse Successfull") ;
		}
		else
		{
			try
			{
				BufferedReader br = new BufferedReader(new FileReader(args[0]));

				StringBuffer query = new StringBuffer();
				int character = br.read();
				while (character != -1)
				{
					query.append((char)character);
					character = br.read();
				}
				jp = Sql.fetchSql(query) ;
				if ( args.length > 0 )
				{
					System.out.println(args[0]) ;
				}
	 			System.out.println("Original Query = " + query);
	 			System.out.println("select = " + jp.getSelect());
//	 			jp.setDistinct();
//	 			System.out.println("select distinct = " + jp.getSelect());
	 			System.out.println("from = " + jp.getFrom());
	 			System.out.println("where = " + jp.getWhere());
	 			System.out.println("connect = " + jp.getConnect());
	 			System.out.println("groupBy = " + jp.getGroupBy());
	 			System.out.println("orderBy = " + jp.getOrderBy());
	 			System.out.println("set = " + jp.getSet());
	 			Vector tables = jp.getTables();
	 			for (int i = 0; i < tables.size(); i++)
	 			{
	 				QueryTable qt = (QueryTable)tables.elementAt(i);
	 				System.out.println("table " + (i+1) + ", name = " + qt.getName() + ",alias = " + qt.getAlias());
	 			}


//				jp.skipOrderBy();
				jp.setOrderBy("ORDER BY test");
				System.out.println("CONSTRUCTED="+jp.getQuery());
				System.out.println("Parse Successfull") ;

			}
			catch (FileNotFoundException e)
			{
				System.out.println("File " + args[0] + " not found.") ;
			}
			catch (IOException e)
			{
				System.out.println("Error reading file " + args[0] + e.getMessage()) ;
			}
		} // else ends here
		System.exit(0);
	}


	/**
	 * Save the original query string.
	 */
	public void setQuery(String query)
	{
		Vector lines = new Vector();
		BufferedReader lineReader = new BufferedReader(new StringReader(query));
		try
		{
			StringBuffer line = new StringBuffer();
			int character;
			while ((character = lineReader.read()) != -1)
			{
				line.append((char)character);
				if ((char)character == '\n')
				{
					lines.addElement(line.toString());
					line.setLength(0);
				}
			}
			if (line.length() > 0) lines.addElement(line.toString());
		}
		catch (IOException io)
		{
			Diagnostics.error("Error reading query: "+io);
		}
		this.query = (String[])lines.toArray(this.query);
	}



	/**
	 * Storage for WHERE clause fragments.
	 * When constructing the WHERE clause, it is necessary to know
	 * if the fragment is to be AND'd or OR'd.
	 */
	private class WhereClause
	{
		boolean and = true;  // If it is not an AND clause, it is an OR clause.
		String clause;

		WhereClause(String clause)
		{
			this.clause = clause;
		}

		WhereClause(String clause, boolean type)
		{
			this.clause = clause;
			this.and = type;
		}

		public String toString()
		{
			return clause;
		}

		boolean isAnd()
		{
			return and;
		}

		boolean isOr()
		{
			return !and;
		}

	}

	/**
	 * A WHERE clause fragment that needs to be AND'd
	 */
	private class AndClause extends WhereClause
	{
		AndClause(String clause)
		{
			super(clause);
		}

	}

	/**
	 * A WHERE clause fragment that needs to be OR'd
	 */
	private class OrClause extends WhereClause
	{
		OrClause(String clause)
		{
			super(clause, false);
		}
	}


	/**
	 * The location in the parsed text.
	 * The parser uses column and line number
	 */
	private class ParserLocation
	{
		int column;
		int line;

		ParserLocation(int inColumn, int inLine)
		{
			column = inColumn;
			line = inLine;
		}

	}

	/**
	 * Use for getting the query clause.
	 */
	private class ParserClause
	{
		ParserLocation begin;
		ParserLocation end;

		void setBegin(int column, int line)
		{
			begin = new ParserLocation(column == 0? 0 : column-1, line);
		}

		void setEnd(int column, int line)
		{
			// Don't change the value if this is the last character of the last line
			if (!(line == query.length && column == query[line-1].length()))
				column = column == 0 ? 0 : column-1;	// and don't go below 0
			end = new ParserLocation(column, line);
		}


		/**
		 * @return the clause as specified by the begin/end location
		 */
		String getClause()
		{
			StringBuffer clause = new StringBuffer();
			if (begin != null)
			{
				for (int i = begin.line; i <=  end.line; i++)
				{
					if (begin.line == end.line) clause.append(query[i-1].substring(begin.column, end.column));	// clause starts and ends on this line
					else if (begin.line == i) clause.append(query[i-1].substring(begin.column));	// clause starts on this line
					else if (end.line == i) clause.append(query[i-1].substring(0, end.column));	// clause ends in this line
					else clause.append(query[i-1]);
				}
			}
			return clause.toString();
		}

	}

} // class SQL ends here

PARSER_END(Sql)


SKIP:
{
    " "
|   "\t"
|   "\r"
|   "\n"
}

/* Prefix      Meaning
    -------------------
    K_          Keyword
    O_          Operator
    S_          Substitutes
*/

TOKEN: /* SQL and PLSQL Keywords. prefixed with K_ to avoid name clashes */
{
    <K_ALL: "ALL">
|   <K_AND: "AND">
|   <K_ANY: "ANY">
|   <K_AS: "AS">
|   <K_ASC:"ASC">
|   <K_BEGIN: "BEGIN">
|   <K_BETWEEN:"BETWEEN">
|   <K_BINARY_INTEGER: "BINARY_INTEGER">
|   <K_BOOLEAN:"BOOLEAN">
|   <K_BY:"BY">
|   <K_CHAR:"CHAR">
|   <K_CLOSE:"CLOSE">
|   <K_COMMENT:"COMMENT">
|   <K_COMMIT:"COMMIT">
|   <K_CONNECT:"CONNECT">
|   <K_CONSTANT:"CONSTANT">
|   <K_CURRENT:"CURRENT">
|   <K_CURSOR:"CURSOR">
|   <K_DATE:"DATE">
|   <K_DECIMAL:"DECIMAL">
|   <K_DECLARE:"DECLARE">
|   <K_DEFAULT:"DEFAULT">
|   <K_DELETE:"DELETE">
|   <K_DESC:"DESC">
|   <K_DISTINCT:"DISTINCT">
|   <K_DO:"DO">
|   <K_ELSE:"ELSE">
|   <K_ELSIF:"ELSIF">
|   <K_END:"END">
|   <K_EXCEPTION:"EXCEPTION">
|   <K_EXCEPTION_INIT:"EXCEPTION_INIT">
|   <K_EXCLUSIVE:"EXCLUSIVE">
|   <K_EXISTS:"EXISTS">
|   <K_EXIT:"EXIT">
|   <K_FETCH:"FETCH">
|   <K_FLOAT:"FLOAT">
|   <K_FOR:"FOR">
|   <K_FROM:"FROM">
|   <K_FULL:"FULL">
|   <K_FUNCTION:"FUNCTION">
|   <K_GOTO:"GOTO">
|   <K_GROUP:"GROUP">
|   <K_HAVING:"HAVING">
|   <K_IF:"IF">
|   <K_IN:"IN">
|   <K_INNER:"INNER">
|   <K_INDEX:"INDEX">
|   <K_INSERT:"INSERT">
|   <K_INTEGER:"INTEGER">
|   <K_INTERSECT:"INTERSECT">
|   <K_INTO:"INTO">
|   <K_IS:"IS">
/*|   <K_LEVEL:"LEVEL">*/
|   <K_JOIN:"JOIN">
|   <K_LEFT:"LEFT">
|   <K_LIKE:"LIKE">
|   <K_LOCK:"LOCK">
|   <K_LOOP:"LOOP">
|   <K_MINUS:"MINUS">
|   <K_MODE:"MODE">
|   <K_NATURAL:"NATURAL">
|   <K_NOT:"NOT">
|   <K_NOWAIT:"NOWAIT">
|   <K_NULL:"NULL">
|   <K_NUMBER:"NUMBER">
|   <K_OF:"OF">
|   <K_ON:"ON">
|   <K_ONLY:"ONLY">
|   <K_OPEN:"OPEN">
|   <K_OR:"OR">
|   <K_ORDER:"ORDER">
|   <K_OTHERS:"OTHERS">
|   <K_OUT:"OUT">
|   <K_OUTER:"OUTER">
|   <K_PACKAGE:"PACKAGE">
|   <K_POSITIVE:"POSITIVE">
|   <K_PRAGMA:"PRAGMA">
|   <K_PRIOR:"PRIOR">
|   <K_PROCEDURE:"PROCEDURE">
|   <K_RAISE:"RAISE">
|   <K_READ:"READ">
|   <K_REAL:"REAL">
|   <K_RECORD:"RECORD">
|   <K_REF:"REF">
|   <K_RETURN:"RETURN">
|   <K_REVERSE:"REVERSE">
|   <K_RIGHT:"RIGHT">
|   <K_ROLLBACK:"ROLLBACK">
|   <K_ROW:"ROW">
|   <K_SAVEPOINT:"SAVEPOINT">
|   <K_SEGMENT:"SEGMENT">
|   <K_SELECT:"SELECT">
|   <K_SET:"SET">
|   <K_SHARE:"SHARE">
|   <K_SMALLINT:"SMALLINT">
|   <K_SQL:"SQL">
|   <K_START:"START">
|   <K_TABLE:"TABLE">
|   <K_THEN:"THEN">
|   <K_TO:"TO">
|   <K_TRANSACTION:"TRANSACTION">
|   <K_UNION:"UNION">
|   <K_UPDATE:"UPDATE">
|   <K_USE:"USE">
|   <K_VALUES:"VALUES">
|   <K_VARCHAR2:"VARCHAR2">
/*|   <K_VARCHAR:"VARCHAR">*/
|   <K_WHEN:"WHEN">
|   <K_WHERE:"WHERE">
|   <K_WHILE:"WHILE">
|   <K_WITH:"WITH">
|   <K_WORK:"WORK">
|   <K_WRITE:"WRITE">
|   <K_CASE:"CASE">
}

TOKEN : /* Numeric Constants */
{
	< S_NUMBER: <FLOAT>
	    | <FLOAT> ( ["e","E"] ([ "-","+"])? <FLOAT> )?
    	>
  | 	< #FLOAT: <INTEGER>
	    | <INTEGER> ( "." <INTEGER> )?
	    | "." <INTEGER>
    	>
  | 	< #INTEGER: ( <DIGIT> )+ >
  | 	< #DIGIT: ["0" - "9"] >
}

SPECIAL_TOKEN:
{
   <LINE_COMMENT: "--"(~["\r","\n"])*>
|  <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}


TOKEN:
{
	< S_IDENTIFIER: ( <LETTER> )+ ( <DIGIT> | <LETTER> |<SPECIAL_CHARS>)* >
| 	< #LETTER: ["a"-"z", "A"-"Z"] >
|   < #SPECIAL_CHARS: "$" | "_">
|   < S_BIND: ":" <S_IDENTIFIER> ("." <S_IDENTIFIER>)? >
|   < S_CHAR_LITERAL: "'" (~["'"])* "'" ("'" (~["'"])* "'")*>
|   < S_QUOTED_IDENTIFIER: "\"" (~["\n","\r","\""])* "\"" >
}

TOKEN:
{
	< S_OUTER: "(" (" ")* "+" (" ")* ")" >
|	< S_LEFT_PAREN: "(" >
|	< S_RIGHT_PAREN: ")" >
/*|	< K_ANSI_JOIN: (((<K_LEFT> | <K_RIGHT> | <K_FULL>) ((" ")* <K_OUTER>)? ) | <K_INNER>) (" ")* <K_JOIN> >*/
|	< K_ORDER_BY: <K_ORDER> (" ")* <K_BY> >
|	< K_GROUP_BY: <K_GROUP> (" ")* <K_BY> >
|	< K_START_WITH: <K_START> (" ")* <K_WITH> >
|	< K_CONNECT_BY: <K_CONNECT> (" ")* <K_BY> >
|	< K_FOR_UPDATE_OF: <K_FOR> (" ")* <K_UPDATE> (" ")* <K_OF> >
}

/* ---------------- General Productions --------------------- */

void TableColumn():
{}
{
	CaseStatement()
	|
    // user.table.column
    OracleObjectName() [ "." OracleObjectName() ["." OracleObjectName()]]
}

Token OracleObjectName():
{ Token oon; }
{
    ( oon = <S_IDENTIFIER> | oon = <S_QUOTED_IDENTIFIER> )
    {
		return oon;
	}
}

void Relop():
{}
{
  "=" | "!=" | "#" | "<>" | ">" | ">=" | "<" | "<=" | "*="
}

QueryTable TableReference():
{ Token t1, t2=null;
QueryTable qt;
}
{
	// user.table
    t1= OracleObjectName() ["." t2 = OracleObjectName()]

	{
		if (t2 == null) qt = new QueryTable(t1.image);
		else qt = new QueryTable(t1.image + "." + t2.image);
		return qt;
	}
}


void NumOrID():
{}
{
    <S_IDENTIFIER> | (["+" | "-"] <S_NUMBER>)
}

void IsNullClause():
{}
{
    "IS" ["NOT"] "NULL"
}


/* --------------- General Productions ends here --------------- */

/* ----------- SQL productions start here ----------------- */

void SelectStatement():
{}
{
	{ selectClause.setBegin(0,1); }
	SelectWithoutOrder() {}
	[ OrderByClause() ]
	[ ForUpdateClause() ]

}

void SelectWithoutOrder():
{}
{
	"SELECT"
		[ "ALL" | "DISTINCT" ]
	{
	if (level == 0  && firstQuery == true)
	{
		distinctClause.setBegin(jj_input_stream.getBeginColumn(), jj_input_stream.getBeginLine());
		distinctClause.setEnd(jj_input_stream.getEndColumn()+1, jj_input_stream.getEndLine());}
	}
		SelectList()
	{
	if (level == 0  && firstQuery == true)
		selectClause.setEnd(jj_input_stream.getBeginColumn(),jj_input_stream.getBeginLine());
	}
	[IntoClause()]
	FromClause()
	[ WhereClause() ]
	[ ConnectClause() ]
	[ GroupByClause() ]
	[ SetClause() ]
}


/* Checks for whatever follows  SELECT */
void SelectList():
{}
{
    "*" | SelectItem() ("," SelectItem())*
}

void SelectItem():
{}
{
  ( LOOKAHEAD(2)
    OracleObjectName()".*"  /* table.* */
|   LOOKAHEAD(4)
    OracleObjectName()"." OracleObjectName() ".*" /* schema.table.* */
|	LOOKAHEAD(2)
	<S_LEFT_PAREN> {level++;} SelectWithoutOrder() {level--;} <S_RIGHT_PAREN>
|   SQLSimpleExpression()    // Column or Expression
)
    [<S_IDENTIFIER>] // Column Alias
}

void IntoClause():
{}
{
   "INTO" IntoItem() ("," IntoItem())*
}

void IntoItem():
{}
{
   (<S_IDENTIFIER> ["." <S_IDENTIFIER>] )
|  (<S_BIND>)
}

void FromClause():
{ if (level == 0 && fromClause.begin == null)
	fromClause.setBegin(jj_input_stream.getBeginColumn(), jj_input_stream.getBeginLine());
}
{
    "FROM" (
           SimpleFromItem() (
              (AnsiFromClause())+
            | ( "," SimpleFromItem())*
            )
         )
    {
    	if (level == 0 && fromClause.end == null)
    	{
			fromClause.setEnd(jj_input_stream.getBeginColumn(), jj_input_stream.getBeginLine());
		}
    }
}

void AnsiFromClause():
{}
{
	 /*<K_ANSI_JOIN> SimpleFromItem() (<K_ON> SQLAndExpression())+ */
	 AnsiJoin() SimpleFromItem() (<K_ON> SQLAndExpression())+ 
}

void SimpleFromItem():
{
	QueryTable qt=null;
	Token alias=null;}
{
   (qt =TableReference() | <S_LEFT_PAREN> {level++;} SubQuery() <S_RIGHT_PAREN>  {level--;})
  [ alias = <S_IDENTIFIER> ]        /** Alias Name **/
	{
		if (qt != null)
		{
			qt.setOriginal();
			if (alias != null)
				qt.setAlias(alias.image);
			if (level == 0 && firstQuery == true)
				tables.addElement(qt);
		}
	}
}


void WhereClause():
{if (level == 0 && whereClause.begin == null)
	whereClause.setBegin(jj_input_stream.getBeginColumn(), jj_input_stream.getBeginLine());}
{
    "WHERE" SQLExpression()
    {
    	if (level == 0 && whereClause.end == null)
    	{
			whereClause.setEnd(jj_input_stream.getBeginColumn(), jj_input_stream.getBeginLine());
		}
    }
}

void ConnectClause():
{if (level == 0 && connectClause.begin == null)
	connectClause.setBegin(jj_input_stream.getBeginColumn(),jj_input_stream.getBeginLine());}
{
    // The following grammar will take 2 "START WITH" expressions
    // which is not correct. But all right, because only valid statements
    // will be given.
   ([<K_START_WITH> SQLExpression()] <K_CONNECT_BY> SQLExpression()
    [<K_START_WITH> SQLExpression()])
    {
    	if (level == 0 && connectClause.end == null)
    	{
			connectClause.setEnd(jj_input_stream.getBeginColumn(),jj_input_stream.getBeginLine());
		}
    }
}

void GroupByClause():
{if (level == 0 && groupByClause.begin == null)
	groupByClause.setBegin(jj_input_stream.getBeginColumn(), jj_input_stream.getBeginLine());}
{
    <K_GROUP_BY> SQLExpressionList()
    ["HAVING" SQLExpression()]
    {
    	if (level == 0 && groupByClause.end == null)
    	{
			groupByClause.setEnd(jj_input_stream.getBeginColumn(), jj_input_stream.getBeginLine());
		}
    }
}

void SetClause():
{if (level == 0 && setClause.begin == null)
	setClause.setBegin(jj_input_stream.getBeginColumn(),jj_input_stream.getBeginLine());}
{
    (("UNION" ["ALL"]) | "INTERSECT" | "MINUS")
    // LOOKAHEAD("(") because Oracle supports "(" after a UNION
    (LOOKAHEAD(<S_LEFT_PAREN>) (<S_LEFT_PAREN> {level++;firstQuery = false;} SelectWithoutOrder() <S_RIGHT_PAREN> {level--;})
        | {firstQuery = false;} SelectWithoutOrder()
    )
    {
    	if (level == 0)
    	{
			setClause.setEnd(jj_input_stream.getBeginColumn(),jj_input_stream.getBeginLine());
		}

    }
}

void OrderByClause():
{if (level == 0)
	orderByClause.setBegin(jj_input_stream.getBeginColumn(),jj_input_stream.getBeginLine());}
{
    <K_ORDER_BY> SQLSimpleExpression() ["ASC" | "DESC" ]
        ("," SQLSimpleExpression() ["ASC" | "DESC"])*
    {
    	if (level == 0)
    	{
			orderByClause.setEnd(jj_input_stream.getBeginColumn(),jj_input_stream.getBeginLine());
		}
    }
}

void ForUpdateClause():
{if (level == 0)
	forUpdateClause.setBegin(jj_input_stream.getBeginColumn(),jj_input_stream.getBeginLine());}
{
    <K_FOR_UPDATE_OF> TableColumn() ("," TableColumn())*
    {
    	if (level == 0)
    	{
			forUpdateClause.setEnd(jj_input_stream.getBeginColumn(),jj_input_stream.getBeginLine());
		}
    }
}

void SQLExpression():
{}
{
    SQLAndExpression() ("OR" SQLAndExpression())*
}

void SQLAndExpression():
{}
{
    SQLUnaryLogicalExpression() ( "AND" SQLUnaryLogicalExpression())*
}

void SQLUnaryLogicalExpression():
{}
{
    LOOKAHEAD(2) ExistsClause()
|   (["NOT"] SQLRelationalExpression())
}

void ExistsClause():
{}
{
    ["NOT"] "EXISTS" <S_LEFT_PAREN> {level++;} SubQuery() <S_RIGHT_PAREN>  {level--;}
}

void SQLRelationalExpression():
{}
{
    /* Only after looking past "(", Expression() and "," we will know that
       it is expression list */

    (LOOKAHEAD(<S_LEFT_PAREN> SQLSimpleExpression() ",")
     <S_LEFT_PAREN> {level++;} SQLExpressionList() <S_RIGHT_PAREN>  {level--;}
|
    (["PRIOR"] SQLSimpleExpression()))

    /* Lookahead(2) is required because of NOT IN,NOT BETWEEN and NOT LIKE */
   ( SQLRelationalOperatorExpression() |  LOOKAHEAD(2) (SQLInClause())
                                    |  LOOKAHEAD(2) (SQLBetweenClause())
                                    |  LOOKAHEAD(2) (SQLLikeClause())
                                    |  IsNullClause()
   )?
}

void SQLExpressionList():
{}
{
    SQLSimpleExpression() ("," SQLSimpleExpression())*
}

void SQLRelationalOperatorExpression():
{}
{

    Relop()

    /* Only after seeing an ANY/ALL or "(" followed by a SubQuery() we can
    determine that is is a sub-query
    */
    (   LOOKAHEAD("ANY" | "ALL" | <S_LEFT_PAREN> "SELECT")
        (["ALL" | "ANY"] <S_LEFT_PAREN> {level++;} SubQuery() <S_RIGHT_PAREN>  {level--;})
        |
        ["PRIOR"] SQLSimpleExpression()
    )
}

void SQLInClause():
{}
{
    ["NOT"] "IN" <S_LEFT_PAREN> {level++;} (SQLExpressionList() | SubQuery()) <S_RIGHT_PAREN>  {level--;}
}

void SQLBetweenClause():
{}
{
    ["NOT"] "BETWEEN" SQLSimpleExpression() "AND" SQLSimpleExpression()
}

void SQLLikeClause():
{}
{
    ["NOT"] "LIKE" SQLSimpleExpression()
}

void SQLSimpleExpression():
{}
{
    SQLMultiplicativeExpression() ( ("+" | "-" | "||") SQLMultiplicativeExpression())*
}


void SQLMultiplicativeExpression():
{}
{
    SQLExponentExpression() ( ("*" | "/") SQLExponentExpression())*
}

void SQLExponentExpression():
{}
{
    SQLUnaryExpression() ( "**" SQLUnaryExpression())*
}

void SQLUnaryExpression():
{}
{
    ["+" | "-"] SQLPrimaryExpression()
}


void SQLPrimaryExpression():
{}
{

    "NULL"
|    LOOKAHEAD(FunctionCall()) FunctionCall()
|    LOOKAHEAD(OuterJoinExpression()) OuterJoinExpression()
|    TableColumn()
|   <S_NUMBER>
|   <S_CHAR_LITERAL>
|   <S_BIND>
|   LOOKAHEAD(2) <S_LEFT_PAREN> {level++;} SQLExpression() <S_RIGHT_PAREN>  {level--;}
|  <S_LEFT_PAREN> {level++;} SelectWithoutOrder() <S_RIGHT_PAREN>  {level--;}
}

void FunctionCall():
{}
{
    // caters the following
    // function(args)
    // package.function(args)
    // user.package.function(args)

    // however note that "distinct/all/*" can be only used with
    // inbuilt functions but no distinction is made between inbuilt
    // function and custom functions

    OracleObjectName() [ "." OracleObjectName() ["." OracleObjectName()]]
    <S_LEFT_PAREN> {level++;} [ ["DISTINCT" | "ALL"] (SQLArguments() | "*") ] <S_RIGHT_PAREN>  {level--;}
}

void SQLArguments():
{}
{
    SQLExpressionList()
}


void OuterJoinExpression():
{}
{
    // user.table.col
    OracleObjectName() [ "." OracleObjectName() ["." OracleObjectName()]]
    <S_OUTER>
}

void SubQuery():
{}
{
    SelectWithoutOrder()
}

void CaseStatement():
{}
{
	<K_CASE> [SQLSimpleExpression()] (<K_WHEN> SQLExpression() <K_THEN> SQLExpression())+ [<K_ELSE> SQLExpression()] <K_END>
}

void AnsiJoin():
{}
{
	[<K_INNER> | ((<K_FULL> | <K_LEFT> | <K_RIGHT>) [<K_OUTER>])] <K_JOIN>
}

